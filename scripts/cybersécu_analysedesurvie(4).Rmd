---
title: "CYBERSECURITE - DUFAY / DENOEL"
output: html_document
date: "2025-10-13"
---

<style>
body {
  background-color: #A1EDFF;
}
</style>

<img src="https://cdn.prod.website-files.com/63a71c562e3ccbc6f6a40f0f/67b98625472de816d0951c58_65bcbb02d38aec8f6ce1f1ab_L%2526D_Cyber%2526ITSecurity_Hero.png"
     width="700"
     style="display:block; margin:auto;" 
     alt="source : Cyber & IT Security Hero">


<div style="text-align: center;">
# **I - INTRODUCTION**
</div>
  
La cybers√©curit√© est aujourd‚Äôhui un enjeu majeur pour les organisations publiques et priv√©es. Face √† la multiplication des attaques informatiques ‚Äî vols de donn√©es, ransomwares, intrusions ‚Äî il devient essentiel de comprendre non seulement la fr√©quence des incidents, mais aussi leur dur√©e avant r√©solution. Dans ce contexte, une analyse de survie permet d‚Äô√©tudier le temps √©coul√© entre la d√©tection d‚Äôun incident et sa r√©solution, tout en tenant compte des facteurs pouvant influencer ce d√©lai (type d‚Äôattaque, secteur d‚Äôactivit√©, niveau de pr√©paration, etc.). Ce type d‚Äôanalyse statistique offre une approche rigoureuse pour identifier les √©l√©ments qui prolongent ou r√©duisent la dur√©e de traitement des incidents de cybers√©curit√©, et ainsi am√©liorer la r√©silience des syst√®mes d‚Äôinformation.




```{r, echo=FALSE, message = FALSE, warning = FALSE}
#INSTALLATION DES PACKAGES NECESSAIRES

#install.packages("readr")
#install.packages("dplyr")

#install.packages("rnaturalearth")
#install.packages("rnaturalearthdata")
#install.packages("sf")

#install.packages("stringr")
#install.packages("biscale")
#install.packages("countrycode")
#install.packages("patchwork")
#install.packages("ggplot2")
```

```{r, echo=FALSE, message = FALSE, warning = FALSE}
library(readr)
library(ggplot2)
library(dplyr)


library(rnaturalearth)
library(rnaturalearthdata)
library(sf)

library(stringr)
library(biscale)
library(countrycode)
library(patchwork)

library(dplyr)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)
library(countrycode)
library(stringr)
library(plotly)

library(dplyr)
library(survival)
library(survminer)
library(ggplot2)
library(gridExtra)
```
<div style="text-align: center;">
# **II - CARACT√âRISTIQUE DES DONN√âES**
</div>



```{r, echo = FALSE, message = FALSE, warning = FALSE}

way_ANNA = "/Users/annad/Documents/MASTER/M2/analyse de survie/data/Global_Cybersecurity_Threats_2015_2024.csv"

way_NIELS = "C:/Users/Denoel/Documents/ETUDES/FAC/2024-2026/MASTER 2024/M2/1 - COURS/S1/ADS FIABILITE/PROJET/cyber_security/Global_Cybersecurity_Threats_2015-2024.csv"

cybersecurity_threat <- read_csv(way_ANNA)

```

## **A) Descriptions des donn√©es**
</div>


```{r, results = 'hide', echo = FALSE, message = FALSE, warning = FALSE}
colnames(cybersecurity_threat)
```

Nous disposons des colonnes suivantes :  
- <u>*Country*</u> : le pays o√π a eu lieu l'attaque;  
- <u>*Year*</u> : l'ann√©e de l'attaque;  
- <u>*Attack Type*</u> : le type d'attaque concern√©e;   
- <u>*Target Industry*</u> : le type d'insdustrie victime de l'attaque;  
- <u>*Financial Loss*</u> : perte financi√®re en million de dollars  
- <u>*Number of affected users*</u> : le nombre d'utilisateurs touch√©s par l'attaque;  
- <u>*Attack source*</u> : le type de personne √† l'origine de l'attaque;  
- <u>*Security vulnerability type*</u> : l'origine de la vuln√©rabilit√© face √† l'attaque;  
- <u>*Defense Mechanism Used*</u> : m√©chainsme de d√©fense utilis√©;  
- <u>*Incident Resolution Time*</u> : temps de r√©solution de l'attaque en heures;


### **B) D√©fintion des √©l√©ments de l'analyse de survie**

- Temporelle : Temps que la d√©fense a pris pour se d√©fendre (Incident Resolution time (hours)) - quelles sont les chances qu'une attaque puisse √™tre r√©solue en un temps limit√© ? (en moins de 3 jours)
- √âv√®nement : cyber attaque
- Censure : 


<div style="text-align: center;">
# **III - ANALYSE EXPLORATOIRE**
</div>

### **A) V√©rification des valeurs NaN:**

```{r, echo = FALSE, message = FALSE, warning = FALSE}

colSums(is.na(cybersecurity_threat))

```

Nous n'avons aucune valeur NaN.

### **B) Histrogramme et Boxplot:**


```{r, echo = FALSE, message = FALSE, warning = FALSE}
# HISTOGRAMME

ggplot(cybersecurity_threat, aes(x = `Incident Resolution Time (in Hours)`)) +
  geom_histogram(binwidth = 1, fill = "#0B78F4", color = "black", alpha = 0.7) +
  labs(
    title = "Histogramme du temps de r√©solution des incidents",
    x = "Dur√©e de r√©solution (heures)",
    y = "Nombre d'incidents"
  ) +
  theme_minimal()


# BOXPLOT

ggplot(cybersecurity_threat, aes(y = `Incident Resolution Time (in Hours)`)) +
  geom_boxplot(fill = "#0B78F4", color = "black", alpha = 0.7, outlier.color = "red", outlier.shape = 16) +
  labs(
    title = "Bo√Æte √† moustaches du temps de r√©solution des incidents",
    y = "Dur√©e de r√©solution (heures)"
  ) +
  theme_minimal()


```


### **C) Carte des attaques:**  
  
  Zoom possible sur la carte :)

```{r, echo = FALSE, message = FALSE, warning = FALSE}

# --- AGR√âGATION DES DONN√âES ---
df_summary <- cybersecurity_threat %>%
  group_by(Country) %>%
  summarise(
    n_attacks = n(),
    mean_resolution = mean(`Incident Resolution Time (in Hours)`, na.rm = TRUE)
  )

# --- HARMONISATION DES NOMS DE PAYS ---
df_summary$country_clean <- countrycode(df_summary$Country,
                                        origin = "country.name",
                                        destination = "country.name")

# Corrige manuellement les √©ventuels NA
df_summary$country_clean[is.na(df_summary$country_clean)] <- df_summary$Country[is.na(df_summary$country_clean)]

# --- IMPORTATION DE LA CARTE DU MONDE ---
world <- ne_countries(scale = "medium", returnclass = "sf")

# --- COORDONN√âES DES CENTRO√èDES DES PAYS ---
centroids <- st_centroid(world)
coords <- as.data.frame(st_coordinates(centroids))
world$long <- coords$X
world$lat <- coords$Y

# --- FUSION DES DONN√âES ---
df_points <- df_summary %>%
  left_join(world %>% st_drop_geometry() %>% select(name, long, lat),
            by = c("country_clean" = "name"))

# --- TRA√áAGE ggplot ---
map <- ggplot() +
  geom_sf(data = world, fill = "gray95", color = "gray80", size = 0.1) +
  geom_point(
    data = df_points,
    aes(
      x = long, y = lat,
      size = n_attacks,
      color = mean_resolution,
      text = paste0(
        "<b>Pays :</b> ", country_clean, "<br>",
        "<b>Nombre d'attaques :</b> ", n_attacks, "<br>",
        "<b>Dur√©e moyenne :</b> ", round(mean_resolution, 1), " h"
      )
    ),
    alpha = 0.85
  ) +
  scale_color_gradient(
    low = "#FFD700",   # jaune clair
    high = "#FF0000",  # rouge vif
    name = "Dur√©e moyenne (heures)"
  ) +
  scale_size_continuous(
    range = c(3, 15),
    name = "Nombre d'attaques"
  ) +
  theme_minimal() +
  labs(
    title = "Cyberattaques dans le monde",
    subtitle = "Taille = nombre d'attaques | Couleur = dur√©e moyenne de r√©solution (heures)",
    caption = "Donn√©es : projet cyberattaques"
  ) +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12)
  )

# --- TRANSFORMATION EN CARTE INTERACTIVE ---
interactive_map <- ggplotly(
  map,
  tooltip = c("text")  # affiche le contenu de aes(text=)
) %>%
  layout(
    legend = list(
      orientation = "v",
      x = 1.05, y = 0.8,
      title = list(text = "<b>L√©gendes</b>")
    )
  ) %>%
  config(
    scrollZoom = TRUE,   # üîç permet le zoom √† la molette
    displaylogo = FALSE, # supprime le logo Plotly
    modeBarButtonsToRemove = c("select2d", "lasso2d") # nettoie la barre d‚Äôoutils
  )

interactive_map
```


<div style="text-align: center;">
# **IV - ANALYSE DE SURVIE**
</div>

### **A) D√©fition des fonctions et des param√®tres**  
  
    

| **FONCTION** | **EXPRESSION** | **DESCRIPTION** |
|:-----------:|:-----------:|:-----------:|
| T | $T$ | La dur√©e de la r√©solution de la cyber-attaque (en heures) |
| S(t) | $P(X>t)$ | Fonction de survie : la probabilit√© que la dur√©e de r√©solution de la cyber-attaque soit sup√©rieure √† $t$ |
| h(t) | $\frac{f(t)}{S(t)}$ | Fonction de risque : la probabilit√© que la r√©solution de la cyber-attaque se termine au moment $t$, √©tant donn√© que l'attaque √©tait encore active jusque-l√† (risque instantan√© de fin d'attaque pour les attaques encore en cours) |
| H(t) | $\int_0^t h(x)\,dx$ | Risque cumul√© |

**La censure**  
  
Etant donn√© que nous n'avons pas de valeurs manquantes, nous n'avons pas de censure. (JAI PAS COMPRIS LA CORR√âLATION ENTRE LES DONN√âES MANQUANTES ET LA CENSURE)

Mais nous pouvons en cr√©er une artificielle, car la moyenne de temps d'une r√©solution d'attaque est de 14h. Nous allons donc assumer que l'entreprise meurt apr√®s 14h sans avoir r√©solu la cyber-attaque.
Nous allons donc cr√©er une censure √† droite. 



Alors cr√©ons deux datasets, un avec la censure √† 14h, l'autre sans censure (l'original pour nous).

```{r}

temps_censure <- 14  # seuil de censure √† droite (en heures)
col_time <- "Incident Resolution Time (in Hours)"

# 1) Partir du tableau complet, cr√©er une vraie colonne num√©rique "time", filtrer proprement
cyber <- cybersecurity_threat %>%
  mutate(time = as.numeric(.data[[col_time]])) %>%
  filter(!is.na(time) & time > 0)

# 2) SANS CENSURE : tous les √©v√©nements sont observ√©s
df_sans_censure <- cyber %>%
  mutate(event = 1)

# 3) AVEC CENSURE : tronquer √† 14 h et marquer les censures
#    (tu peux mettre <= au lieu de < selon ta convention)
df_avec_censure <- cyber %>%
  mutate(
    time  = pmin(time, temps_censure),
    event = ifelse(.data[[col_time]] < temps_censure, 1, 0)
  )


```


REFAIRE LES CALCULS TOIUT EN DESSOUS EN UTILISANT LES DEUC DATASETS



Illustration pour mieux comprendre la censure √† droite 


je pense qu'il faudra modifier le nom du dataset quand il faut recharger le rmd
```{r}
library(ggplot2)
library(dplyr)

# --- Jeu de donn√©es d'exemple ---
set.seed(123)
n <- 10  # nombre d'incidents
temps_censure <- 14

# Dur√©es al√©atoires (entre 2h et 25h)
df_demo <- data.frame(
  id = factor(1:n),
  time_true = runif(n, 2, 25)
) %>%
  mutate(
    time_obs = pmin(time_true, temps_censure),
    event = ifelse(time_true <= temps_censure, 1, 0)
  )

# --- Trac√© ---
ggplot(df_demo, aes(y = id)) +
  geom_segment(aes(x = 0, xend = time_obs, yend = id,
                   color = factor(event)), linewidth = 1.2) +
  geom_point(aes(x = time_obs, shape = factor(event), color = factor(event)), size = 3) +
  scale_color_manual(values = c("0" = "#D55E00", "1" = "#0072B2"),
                     labels = c("0" = "Censur√© (|)", "1" = "√âv√©nement (‚ùå)")) +
  scale_shape_manual(values = c("0" = 124, "1" = 4),  # | et X
                     labels = c("0" = "Censur√©", "1" = "√âv√©nement")) +
  labs(
    title = "Illustration de la censure √† droite (seuil = 14 h)",
    x = "Temps (heures)",
    y = "Incident",
    color = "Statut",
    shape = "Statut"
  ) +
  geom_vline(xintercept = temps_censure, linetype = "dashed", color = "grey40") +
  annotate("text", x = temps_censure + 0.5, y = n + 0.5,
           label = "Seuil de censure (14 h)", hjust = 0, size = 3.5, color = "grey40") +
  theme_minimal(base_size = 13) +
  theme(legend.position = "bottom",
        plot.title = element_text(face = "bold", hjust = 0.5))

```












## **B) Estimation des fonctions**


### **KAPLAN MEIEIR pour la fonction de survie S(t)**

On s√©lectionne uniquement la colonne de temps et on la renomme proprement


```{r}
df <- cybersecurity_threat %>%
  select(`Incident Resolution Time (in Hours)`) %>%
  rename(time_hours = `Incident Resolution Time (in Hours)`) %>%
  filter(!is.na(time_hours))

# df est donc juste une copie du dataset de base o√π on a juste renomm√© la colonne de temps avec un autre nom.

```


Forumule avec censure : 

$$
\widehat{S}(t) = \prod_{t_i \le t} \left(1 - \frac{d_i}{n_i}\right)
$$
```{r}
fit_avec  <- survfit(Surv(time, event) ~ 1, data = df_avec_censure)

df_avec_plot <- data.frame(
  time = fit_avec$time,
  surv = fit_avec$surv,
  type = "Avec censure (14h)"
)

ggplot(df_avec_plot, aes(x = time, y = surv)) +
  geom_step(linewidth = 1.1) +
  labs(title = "Courbe de survie Kaplan‚ÄìMeier (avec censure)",
       x = "Temps (heures)", y = "S(t)") +
  coord_cartesian(ylim = c(0, 1)) +
  theme_minimal(base_size = 13)

```





Formule sans censure :

$$
S(t) = [S(t - 1)] \cdot \left( 1 - \frac{d}{n} \right)
$$


```{r}

fit_sans  <- survfit(Surv(time, event) ~ 1, data = df_sans_censure)

df_sans_plot <- data.frame(
  time = fit_sans$time,
  surv = fit_sans$surv,
  type = "Sans censure"
)

ggplot(df_sans_plot, aes(x = time, y = surv)) +
  geom_step(linewidth = 1.1) +
  labs(title = "Courbe de survie Kaplan‚ÄìMeier (sans censure)",
       x = "Temps (heures)", y = "S(t)") +
  coord_cartesian(ylim = c(0, 1)) +
  theme_minimal(base_size = 13)
```



```{r}

df_combined <- rbind(df_sans_plot, df_avec_plot)

ggplot() +
  geom_step(data = df_sans_plot, aes(time, surv, color = "Sans censure"), linewidth = 1.1) +
  geom_step(data = df_avec_plot, aes(time, surv, color = "Avec censure (14h)"),
            linewidth = 1.1, linetype = "dashed") +
  scale_color_manual(values = c("Sans censure" = "#0072B2",
                                "Avec censure (14h)" = "red")) +
  labs(
    title = "Courbes de survie Kaplan‚ÄìMeier",
    x = "Temps (heures)",
    y = "Probabilit√© de survie S(t)"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.title = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5)
  )



```

On peut faire apr√®s les courbes selon l'industrie, les pays ou encore les types de d√©fenses utilis√©s etc. -> √† faire lol

#### BIAIS

L'estimateur de Kaplan-Meier est biais√©, mais asymptotiquement sans biais. 



√† modifier : Le biais est une mesure de l'√©cart entre l'estimation de Kaplan-Meier et la vraie fonction de survie. Il indique si l'estimateur surestime ou sous-estime la probabilit√© de survie √† un moment donn√©. Ici, le biais est positif, cela signifie que l'estimateur de Kaplan-Meier est enclin √† surestimer la probabilit√© de survie par rapport √† la r√©alit√©.


```{r}

# Suppose qu'on utilise df_avec_censure
t <- 14  # par exemple
fit <- survfit(Surv(time, event) ~ 1, data = df_avec_censure)

# --- 1) Survie estim√©e par Kaplan‚ÄìMeier √† t ---
observed_survival <- summary(fit, times = t)$surv

# --- 2) Survie empirique "na√Øve" ---
# proportion d'incidents r√©solus avant t
prop_resolus <- mean(df_avec_censure$event[df_avec_censure$time <= t])
expected_survival <- 1 - prop_resolus

# --- 3) Biais ---
bias <- observed_survival - expected_survival

bias
```

```{r}
library(survival)

# Jeu sans censure
t <- 14  # par exemple 14 heures

fit_no_cens <- survfit(Surv(time, event) ~ 1, data = df_sans_censure)

# --- 1) Survie estim√©e par Kaplan‚ÄìMeier √† t ---
observed_survival_no_cens <- summary(fit_no_cens, times = t)$surv

# --- 2) Survie empirique (sans censure, donc simplement le % de cas > t) ---
expected_survival_no_cens <- mean(df_sans_censure$time > t)

# --- 3) Biais ---
bias_no_cens <- observed_survival_no_cens - expected_survival_no_cens

bias_no_cens

```

On a le m√™me biais mais on devait s'y attendre par rapport √† la courbe de Kaplan-Meier qu'on a obtenu avant.

JE NE SAIS PAS COMMENT R√âGLER √áANLOLOL

#### VARIANCE 



??? INCONNUE AU BATAILLON POUR L'INSTANT






## **NELSON AALEN pour la fonction de risque cumulative H(t)**

H(t) est d√©finie comme la somme cumulative des risques au fil du temps. Elle est souvent utilis√©e lorsque les donn√©es de survie sont censur√©es.

Formule avec censure :
$$
H(t) = \sum_{t_i \le t} \frac{d_i}{n_i}
$$
```{r}
# --- Avec censure (14h) ---
fit_na_avec <- survfit(Surv(time, event) ~ 1,
                       data = df_avec_censure,
                       type = "fleming-harrington")

df_H_avec <- data.frame(
  time = fit_na_avec$time,
  H    = -log(pmax(fit_na_avec$surv, 1e-12)),
  type = "Avec censure (14h)"
)


```



Formule sans censure : 
$$
H(t) = \sum_{i} \frac{d_i}{n_i}
$$

```{r}
# --- Sans censure ---
fit_na_sans <- survfit(Surv(time, event) ~ 1,
                       data = df_sans_censure,
                       type = "fleming-harrington")

df_H_sans <- data.frame(
  time = fit_na_sans$time,
  H    = -log(pmax(fit_na_sans$surv, 1e-12)),
  type = "Sans censure"
)



```


trac√© des deux courbes

```{r}
df_H <- bind_rows(df_H_sans, df_H_avec)

# --- Trac√© ---
ggplot(df_H, aes(x = time, y = H, color = type, linetype = type)) +
  geom_step(linewidth = 1.1) +
  labs(title = "Risque cumul√©e H(t) ‚Äî estimateur de Nelson‚ÄìAalen",
       x = "Temps (heures)", y = "H(t)") +
  scale_color_manual(values = c("Sans censure" = "#0072B2",
                                "Avec censure (14h)" = "#D55E00")) +
  scale_linetype_manual(values = c("Sans censure" = "solid",
                                   "Avec censure (14h)" = "dashed")) +
  theme_minimal(base_size = 13) +
  theme(legend.title = element_blank(),
        plot.title = element_text(face = "bold", hjust = 0.5))

```


m√™me probl√®me, les deux courbes se confondent mais va s'y j'ai la flemme 




## **DENSIT√â& DE RISQUE INSTANT&E h(t)**

La densit√© du risque instantan√© h(t) est d√©finie comme le rapport du nombre d'√©v√©nements observ√©s √† un instant donn√© au nombre de sujets encore √† risque √† cet instant

Formule sans censure :
$$
h(t) = \frac{d}{n}
$$


Formule avec cendure :

$$
h(t) = \sum_i \frac{d_i}{n_i}
$$




```{r}
library(dplyr)
library(ggplot2)

# Combine les deux courbes de survie
df_combined <- bind_rows(df_sans_plot, df_avec_plot)

# Calcule H(t) et h(t) ‚âà ŒîH / Œît
df_hazard <- df_combined %>%
  group_by(type) %>%
  arrange(time, .by_group = TRUE) %>%
  mutate(
    H = -log(pmax(surv, 1e-12)),              # H(t) = -log(S(t))
    h = (H - lag(H)) / (time - lag(time))     # h(t) par diff√©rences finies
  )

# Supprime les premi√®res lignes NA
df_hazard <- df_hazard %>% filter(!is.na(h))

# --- Trac√© de h(t) ---
ggplot(df_hazard, aes(x = time, y = h, color = type, linetype = type)) +
  geom_step(linewidth = 1.1) +
  labs(title = "Densit√© de risque instantan√© h(t)",
       subtitle = "Comparaison entre jeu avec et sans censure",
       x = "Temps (heures)",
       y = "h(t) ‚Äî Densit√© de risque instantan√©") +
  scale_color_manual(values = c("Sans censure" = "#0072B2",
                                "Avec censure (14h)" = "#D55E00")) +
  scale_linetype_manual(values = c("Sans censure" = "solid",
                                   "Avec censure (14h)" = "dashed")) +
  theme_minimal(base_size = 13) +
  theme(
    legend.title = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )

```


## **Estimateur de BRESLOW**

mod√®le de Cox sans covariable ‚Üí la baseline hazard est l‚Äôestimateur de Breslow

L'estimateur de Breslow est obtenu √† partir de l'estimateur de Kaplan-Meier. Sa formule est la suivante : -> √† v√©rifier

$$
\hat{H}_{BR} = -\log(\hat{S}_{KM})
$$
o√π :
$$
\hat{S}_{KM}(t) = \prod_{i = 1,\, t_i < t} (1 - d_i Y_i)
$$



L'estimateur de Breslow est utilis√© pour estimer la fonction de survie dans le mod√®le de r√©gression de Cox. Il permet de tenir compte de la censure dans les donn√©es de survie et fournit une estimation adapt√©e pour les √©chantillons censur√©s.

Formule sans censure :
$$
H(t) = \sum_{t_i \le t} \frac{d_i}{n_i}
$$

```{r}
cox_sans_censure  <- coxph(Surv(time, event) ~ 1, data = df_sans_censure)

H_sans <- basehaz(cox_sans_censure, centered = FALSE) %>%
  transmute(time = time,
            H = hazard / max(hazard, na.rm = TRUE),
            type = "Sans censure")
```


Formule avec censure :

$$
H(t) = \sum_{t_i \le t} \sum_{j \le t_i} \frac{d_{ij}}{n_{ij}}
$$

```{r}
cox_avec_censure  <- coxph(Surv(time, event) ~ 1, data = df_avec_censure)

H_avec <- basehaz(cox_avec_censure, centered = FALSE) %>%
  transmute(time = time,
            H = hazard / max(hazard, na.rm = TRUE),   
            type = "Avec censure (14h)")

```



trac√© des deux courbes

```{r}
df_breslow <- bind_rows(H_avec, H_sans)

# --- üé® Trac√© final ---
ggplot(df_breslow, aes(x = time, y = H, color = type, linetype = type)) +
  geom_step(linewidth = 1.2) +
  labs(
    title = "Estimation de la fonction de risque cumul√©e H(t) ‚Äî M√©thode de Breslow",
    subtitle = "Comparaison entre jeu avec et sans censure",
    x = "Temps (heures)",
    y = "Fonction de risque cumul√© H(t) normalis√©e"
  ) +
  scale_color_manual(values = c("Sans censure" = "#0072B2",
                                "Avec censure (14h)" = "#D55E00")) +
  scale_linetype_manual(values = c("Sans censure" = "solid",
                                   "Avec censure (14h)" = "dashed")) +
  theme_minimal(base_size = 13) +
  theme(
    legend.title = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )

```


## **LOG RANK**

Le test du log-rank compare les courbes de survie de deux groupes distincts. L'hypoth√®se nulle du test est que les deux groupes proviennent de la m√™me population, c'est-√†-dire qu'il n'y a pas de diff√©rence significative entre les distributions de survie des deux groupes.


Ici, nous allons comparer les distributions des courbes quand les donn√©es sont censur√©es vs non-censur√©es. Nous allons d√©terminer s'il y a une diff√©rence significative dans la distribution des temps de survie entre ces groupes.

Si le test du log-rank donne un r√©sultat significatif, cela sugg√®re que les courbes de survie sont diff√©rentes, indiquant une variation significative dans les temps de survie entre les groupes compar√©s. En revanche, si le test n'est pas significatif, on n'a pas suffisamment de preuves pour rejeter l'hypoth√®se nulle, ce qui signifie que les courbes de survie peuvent √™tre consid√©r√©es comme provenant de la m√™me population.


## **COX (semi-param√©trique) -> j'ai pas compris encore**




## **C) Estimation param√©trique (ou non param√©trique, jsp dans notre cas pour l'instanbt)**

# **V - MACHINE-LEARNING**


