---
title: "CYBERSECURITE - DUFAY / DENOEL"
output: html_document
date: "2025-10-13"
---

<style>
body {
  background-color: #A1EDFF;
}
</style>

<img src="https://cdn.prod.website-files.com/63a71c562e3ccbc6f6a40f0f/67b98625472de816d0951c58_65bcbb02d38aec8f6ce1f1ab_L%2526D_Cyber%2526ITSecurity_Hero.png"
     width="700"
     style="display:block; margin:auto;" 
     alt="source : Cyber & IT Security Hero">


<div style="text-align: center;">
# **I - INTRODUCTION**
</div>
  
La cybers√©curit√© est aujourd‚Äôhui un enjeu majeur pour les organisations publiques et priv√©es. Face √† la multiplication des attaques informatiques ‚Äî vols de donn√©es, ransomwares, intrusions ‚Äî il devient essentiel de comprendre non seulement la fr√©quence des incidents, mais aussi leur dur√©e avant r√©solution. Dans ce contexte, une analyse de survie permet d‚Äô√©tudier le temps √©coul√© entre la d√©tection d‚Äôun incident et sa r√©solution, tout en tenant compte des facteurs pouvant influencer ce d√©lai (type d‚Äôattaque, secteur d‚Äôactivit√©, niveau de pr√©paration, etc.). Ce type d‚Äôanalyse statistique offre une approche rigoureuse pour identifier les √©l√©ments qui prolongent ou r√©duisent la dur√©e de traitement des incidents de cybers√©curit√©, et ainsi am√©liorer la r√©silience des syst√®mes d‚Äôinformation.




```{r, echo=FALSE, message = FALSE, warning = FALSE}
#INSTALLATION DES PACKAGES NECESSAIRES

#install.packages("readr")
#install.packages("dplyr")

#install.packages("rnaturalearth")
#install.packages("rnaturalearthdata")
#install.packages("sf")

#install.packages("stringr")
#install.packages("biscale")
#install.packages("countrycode")
#install.packages("patchwork")
#install.packages("ggplot2")
```

```{r, echo=FALSE, message = FALSE, warning = FALSE}
library(readr)
library(ggplot2)
library(dplyr)


library(rnaturalearth)
library(rnaturalearthdata)
library(sf)

library(stringr)
library(biscale)
library(countrycode)
library(patchwork)

library(dplyr)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)
library(countrycode)
library(stringr)
library(plotly)

```
<div style="text-align: center;">
# **II - CARACT√âRISTIQUE DES DONN√âES**
</div>



```{r, echo = FALSE, message = FALSE, warning = FALSE}

way_ANNA = "/Users/annad/Documents/MASTER/M2/analyse de survie/data/Global_Cybersecurity_Threats_2015_2024.csv"

way_NIELS = "C:/Users/Denoel/Documents/ETUDES/FAC/2024-2026/MASTER 2024/M2/1 - COURS/S1/ADS FIABILITE/PROJET/cyber_security/Global_Cybersecurity_Threats_2015-2024.csv"

cybersecurity_threat <- read_csv(way_ANNA)

```

## **A) Descriptions des donn√©es**
</div>


```{r, results = 'hide', echo = FALSE, message = FALSE, warning = FALSE}
colnames(cybersecurity_threat)
```

Nous disposons des colonnes suivantes :  
- <u>*Country*</u> : le pays o√π a eu lieu l'attaque;  
- <u>*Year*</u> : l'ann√©e de l'attaque;  
- <u>*Attack Type*</u> : le type d'attaque concern√©e;   
- <u>*Target Industry*</u> : le type d'insdustrie victime de l'attaque;  
- <u>*Financial Loss*</u> : perte financi√®re en million de dollars  
- <u>*Number of affected users*</u> : le nombre d'utilisateurs touch√©s par l'attaque;  
- <u>*Attack source*</u> : le type de personne √† l'origine de l'attaque;  
- <u>*Security vulnerability type*</u> : l'origine de la vuln√©rabilit√© face √† l'attaque;  
- <u>*Defense Mechanism Used*</u> : m√©chainsme de d√©fense utilis√©;  
- <u>*Incident Resolution Time*</u> : temps de r√©solution de l'attaque en heures;


### **B) D√©fintion des √©l√©ments de l'analyse de survie**

- Temporelle : Temps que la d√©fense a pris pour se d√©fendre (Incident Resolution time (hours)) - quelles sont les chances qu'une attaque puisse √™tre r√©solue en un temps limit√© ? (en moins de 3 jours)
- √âv√®nement : cyber attaque
- Censure : 


<div style="text-align: center;">
# **III - ANALYSE EXPLORATOIRE**
</div>

### **A) V√©rification des valeurs NaN:**

```{r, echo = FALSE, message = FALSE, warning = FALSE}

colSums(is.na(cybersecurity_threat))

```

Nous n'avons aucune valeur NaN.

### **B) Histrogramme et Boxplot:**


```{r, echo = FALSE, message = FALSE, warning = FALSE}
# HISTOGRAMME

ggplot(cybersecurity_threat, aes(x = `Incident Resolution Time (in Hours)`)) +
  geom_histogram(binwidth = 1, fill = "#0B78F4", color = "black", alpha = 0.7) +
  labs(
    title = "Histogramme du temps de r√©solution des incidents",
    x = "Dur√©e de r√©solution (heures)",
    y = "Nombre d'incidents"
  ) +
  theme_minimal()


# BOXPLOT

ggplot(cybersecurity_threat, aes(y = `Incident Resolution Time (in Hours)`)) +
  geom_boxplot(fill = "#0B78F4", color = "black", alpha = 0.7, outlier.color = "red", outlier.shape = 16) +
  labs(
    title = "Bo√Æte √† moustaches du temps de r√©solution des incidents",
    y = "Dur√©e de r√©solution (heures)"
  ) +
  theme_minimal()


```


### **C) Carte des attaques:**  
  
  Zoom possible sur la carte :)

```{r, echo = FALSE, message = FALSE, warning = FALSE}

# --- AGR√âGATION DES DONN√âES ---
df_summary <- cybersecurity_threat %>%
  group_by(Country) %>%
  summarise(
    n_attacks = n(),
    mean_resolution = mean(`Incident Resolution Time (in Hours)`, na.rm = TRUE)
  )

# --- HARMONISATION DES NOMS DE PAYS ---
df_summary$country_clean <- countrycode(df_summary$Country,
                                        origin = "country.name",
                                        destination = "country.name")

# Corrige manuellement les √©ventuels NA
df_summary$country_clean[is.na(df_summary$country_clean)] <- df_summary$Country[is.na(df_summary$country_clean)]

# --- IMPORTATION DE LA CARTE DU MONDE ---
world <- ne_countries(scale = "medium", returnclass = "sf")

# --- COORDONN√âES DES CENTRO√èDES DES PAYS ---
centroids <- st_centroid(world)
coords <- as.data.frame(st_coordinates(centroids))
world$long <- coords$X
world$lat <- coords$Y

# --- FUSION DES DONN√âES ---
df_points <- df_summary %>%
  left_join(world %>% st_drop_geometry() %>% select(name, long, lat),
            by = c("country_clean" = "name"))

# --- TRA√áAGE ggplot ---
map <- ggplot() +
  geom_sf(data = world, fill = "gray95", color = "gray80", size = 0.1) +
  geom_point(
    data = df_points,
    aes(
      x = long, y = lat,
      size = n_attacks,
      color = mean_resolution,
      text = paste0(
        "<b>Pays :</b> ", country_clean, "<br>",
        "<b>Nombre d'attaques :</b> ", n_attacks, "<br>",
        "<b>Dur√©e moyenne :</b> ", round(mean_resolution, 1), " h"
      )
    ),
    alpha = 0.85
  ) +
  scale_color_gradient(
    low = "#FFD700",   # jaune clair
    high = "#FF0000",  # rouge vif
    name = "Dur√©e moyenne (heures)"
  ) +
  scale_size_continuous(
    range = c(3, 15),
    name = "Nombre d'attaques"
  ) +
  theme_minimal() +
  labs(
    title = "Cyberattaques dans le monde",
    subtitle = "Taille = nombre d'attaques | Couleur = dur√©e moyenne de r√©solution (heures)",
    caption = "Donn√©es : projet cyberattaques"
  ) +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12)
  )

# --- TRANSFORMATION EN CARTE INTERACTIVE ---
interactive_map <- ggplotly(
  map,
  tooltip = c("text")  # affiche le contenu de aes(text=)
) %>%
  layout(
    legend = list(
      orientation = "v",
      x = 1.05, y = 0.8,
      title = list(text = "<b>L√©gendes</b>")
    )
  ) %>%
  config(
    scrollZoom = TRUE,   # üîç permet le zoom √† la molette
    displaylogo = FALSE, # supprime le logo Plotly
    modeBarButtonsToRemove = c("select2d", "lasso2d") # nettoie la barre d‚Äôoutils
  )

interactive_map
```


<div style="text-align: center;">
# **IV - ANALYSE DE SURVIE**
</div>

### **A) D√©fition des fonctions et des param√®tres**  
  
    

| **FONCTION** | **EXPRESSION** | **DESCRIPTION** |
|:-----------:|:-----------:|:-----------:|
| T | $T$ | La dur√©e de la r√©solution de la cyber-attaque (en heures) |
| S(t) | $P(X>t)$ | Fonction de survie : la probabilit√© que la dur√©e de r√©solution de la cyber-attaque soit sup√©rieure √† $t$ |
| h(t) | $\frac{f(t)}{S(t)}$ | Fonction de risque : la probabilit√© que la r√©solution de la cyber-attaque se termine au moment $t$, √©tant donn√© que l'attaque √©tait encore active jusque-l√† (risque instantan√© de fin d'attaque pour les attaques encore en cours) |
| H(t) | $\int_0^t h(x)\,dx$ | Risque cumul√© |

**La censure**  
  
Etant donn√© que nous n'avons pas de valeurs manquantes, nous n'avons pas de censure. (JAI PAS COMPRIS LA CORR√âLATION ENTRE LES DONN√âES MANQUANTES ET LA CENSURE)

Mais nous pouvons en cr√©er une artificielle, car la moyenne de temps d'une r√©solution d'attaque est de 14h. 
Nous allons donc cr√©er une censure √† droite. 



## **B) Estimation des fonctions**


### **KAPLAN MEIEIR pour la fonction de survie S(t)**

Forumule avec censure : 

$$
\widehat{S}(t) = \prod_{t_i \le t} \left(1 - \frac{d_i}{n_i}\right)
$$


```{r}
# =========================
# --- PACKAGES ---
# =========================
library(dplyr)
library(survival)
library(survminer)
library(ggplot2)
library(gridExtra)

# =========================
# --- PR√âPARATION ---
# =========================
# On s√©lectionne uniquement la colonne de temps et on la renomme proprement
df <- cybersecurity_threat %>%
  select(`Incident Resolution Time (in Hours)`) %>%
  rename(time_hours = `Incident Resolution Time (in Hours)`) %>%
  filter(!is.na(time_hours))

# =========================
# A) KAPLAN‚ÄìMEIER SANS CENSURE
# =========================
df <- df %>%
  mutate(event_all = 1L)  # tout est observ√©

# mod√®le KM complet
fit_all <- survfit(Surv(time_hours, event_all) ~ 1, data = df)

# M√©diane (temps o√π S(t) = 0.5)
median_all <- as.numeric(summary(fit_all)$table["median"])

# Graphique
p_all <- ggsurvplot(
  fit_all,
  conf.int = TRUE,
  xlab = "Temps (heures)",
  ylab = "S(t) = P(T > t)",
  title = "Kaplan‚ÄìMeier sans censure",
  surv.scale = "percent"
)$plot + theme_minimal()

# =========================
# B) KAPLAN‚ÄìMEIER AVEC CENSURE √Ä 14h
# =========================
df <- df %>%
  mutate(
    time14  = pmin(time_hours, 14),         # tronque les temps √† 14 h
    event14 = as.integer(time_hours <= 14)  # 1 si r√©solu avant ou √† 14 h
  )

fit_14 <- survfit(Surv(time14, event14) ~ 1, data = df)

# Extraction de S(14) et IC95 %
s14 <- summary(fit_14, times = 14)
S14      <- as.numeric(s14$surv)
S14_low  <- as.numeric(s14$lower)
S14_high <- as.numeric(s14$upper)
F14      <- 1 - S14
F14_low  <- 1 - S14_high
F14_high <- 1 - S14_low

median_14 <- as.numeric(summary(fit_14)$table["median"])

# Graphique censur√©
p_14 <- ggsurvplot(
  fit_14,
  conf.int = TRUE,
  xlab = "Temps (heures)",
  ylab = "S(t) = P(T > t)",
  title = "Kaplan‚ÄìMeier avec censure √† 14 h",
  surv.scale = "percent"
)$plot + theme_minimal() +
  geom_vline(xintercept = 14, linetype = "dashed")

# =========================
# C) AFFICHAGE C√îTE √Ä C√îTE
# =========================
grid.arrange(p_all, p_14, ncol = 2)

# =========================
# D) R√âSUM√âS NUM√âRIQUES
# =========================
cat("\n--- SANS CENSURE ---\n")
cat("M√©diane de survie (heures):", median_all, "\n")

cat("\n--- CENSURE ADMINISTRATIVE √Ä 14h ---\n")
cat("S(14) =", round(S14, 4), " | IC95% [", round(S14_low, 4), ", ", round(S14_high, 4), "]\n", sep = "")
cat("F(14) = 1 - S(14) =", round(F14, 4), " | IC95% [", round(F14_low, 4), ", ", round(F14_high, 4), "]\n", sep = "")
cat("M√©diane (sous censure 14 h):", median_14, " (NA si < 50% d'√©v√©nements avant 14 h)\n")


```


On peut faire apr√®s les courbes selon l'industrie, les pays ou encore les types de d√©fenses utilis√©s etc.

#### BIAIS

#### VARIANCE 



## **NELSON AALEN pour la fonction de risque cumulative H(t)**

avec et sans censure formules ?

```{r}
# Packages
library(dplyr)
library(survival)
library(ggplot2)
library(tidyr)
library(gridExtra)

# ===== 0) Pr√©parer les donn√©es =====
df0 <- cybersecurity_threat %>%
  select(`Incident Resolution Time (in Hours)`) %>%
  rename(time_hours = `Incident Resolution Time (in Hours)`) %>%
  filter(!is.na(time_hours))

# ===== 1) Kaplan‚ÄìMeier SANS censure =====
df_all <- df0 %>% mutate(event = 1L)
fit_all <- survfit(Surv(time_hours, event) ~ 1, data = df_all)

s_all <- summary(fit_all)
km_all <- data.frame(
  time   = s_all$time,
  S      = s_all$surv,
  nevent = s_all$n.event,
  nrisk  = s_all$n.risk
) %>%
  mutate(
    F = 1 - S,
    H = cumsum(nevent / nrisk),        # Nelson‚ÄìAalen
    hazard_increment = nevent / nrisk  # incr√©ment discret h(t_i)
  )

# ===== 2) Kaplan‚ÄìMeier AVEC censure admin √† 14 h =====
df_14 <- df0 %>%
  mutate(
    time   = pmin(time_hours, 14),
    event  = as.integer(time_hours <= 14)
  )
fit_14 <- survfit(Surv(time, event) ~ 1, data = df_14)

s_14 <- summary(fit_14)
km_14 <- data.frame(
  time   = s_14$time,
  S      = s_14$surv,
  nevent = s_14$n.event,
  nrisk  = s_14$n.risk
) %>%
  mutate(
    F = 1 - S,
    H = cumsum(nevent / nrisk),
    hazard_increment = nevent / nrisk
  )

# ===== 3) Trac√©s comparatifs =====

# (A) Risque cumul√© H(t) : Nelson‚ÄìAalen
p_H <- ggplot() +
  geom_step(data = km_all, aes(x = time, y = H), size = 1, alpha = 0.9) +
  geom_step(data = km_14, aes(x = time, y = H), linetype = "dashed") +
  labs(title = "Risque cumul√© H(t) ‚Äî Nelson‚ÄìAalen",
       x = "Temps (heures)", y = "H(t)") +
  theme_minimal()

# (B) Fonction de r√©partition F(t) = 1 - S(t)
p_F <- ggplot() +
  geom_step(data = km_all, aes(x = time, y = F), size = 1, alpha = 0.9) +
  geom_step(data = km_14, aes(x = time, y = F), linetype = "dashed") +
  labs(title = "Fonction de r√©partition F(t) = 1 - S(t)",
       x = "Temps (heures)", y = "F(t)") +
  theme_minimal()

# (C) Incr√©ments de hazard (discret) d_i / n_i
p_h <- ggplot() +
  geom_step(data = km_all, aes(x = time, y = hazard_increment), size = 1, alpha = 0.9) +
  geom_step(data = km_14, aes(x = time, y = hazard_increment), linetype = "dashed") +
  labs(title = "Incr√©ments de hazard (discrets) d_i / n_i",
       x = "Temps (heures)", y = "ŒîH(t_i) = d_i / n_i") +
  theme_minimal()

grid.arrange(p_H, p_F, p_h, ncol = 1)

# ===== 4) Quelques valeurs √† 14 h =====
# S(14) et F(14) sans censure (lecture par approximation au dernier temps <= 14)
S14_all <- km_all %>% filter(time <= 14) %>% tail(1) %>% pull(S)
F14_all <- 1 - S14_all

# S(14) et F(14) avec censure
S14_cens <- km_14 %>% filter(time == max(time)) %>% tail(1) %>% pull(S)
F14_cens <- 1 - S14_cens

cat("Sans censure : S(14) ‚âà", round(S14_all, 4), " | F(14) ‚âà", round(F14_all, 4), "\n")
cat("Avec censure  : S(14) =", round(S14_cens, 4), " | F(14) =", round(F14_cens, 4), "\n")

```


## **DENSIT√â& DE RISQUE INSTANT&E h(t)**

avec et sans censure formules ?

√† partir de kaplan-meier

```{r}
# --- Packages ---
library(dplyr)
library(survival)
library(ggplot2)

# --- 0) Prepare data: create a clean 'time_hours' column ---
df <- cybersecurity_threat %>%
  select(`Incident Resolution Time (in Hours)`) %>%
  rename(time_hours = `Incident Resolution Time (in Hours)`) %>%
  filter(!is.na(time_hours))

# ================================
# 1) KM WITHOUT CENSORING
# ================================
df_all <- df %>% mutate(event = 1L)  # all events observed
fit_all <- survfit(Surv(time_hours, event) ~ 1, data = df_all)

s_all <- summary(fit_all)
km_all <- data.frame(
  time   = s_all$time,
  S      = s_all$surv,
  nevent = s_all$n.event,
  nrisk  = s_all$n.risk
) %>%
  mutate(
    S_prev = dplyr::lag(S, default = 1),        # S(t-) (pre-jump survival)
    # Discrete hazard increment h(t_i) = ŒîH_i = d_i / n_i = 1 - S_i / S_{i-1}
    h_inc  = 1 - (S / S_prev)
  )

# ================================
# 2) KM WITH ADMIN CENSORING AT 14h
# ================================
df_14 <- df %>%
  mutate(
    time  = pmin(time_hours, 14),           # truncate at 14h
    event = as.integer(time_hours <= 14)    # 1 if resolved by 14h, else censored
  )

fit_14 <- survfit(Surv(time, event) ~ 1, data = df_14)

s_14 <- summary(fit_14)
km_14 <- data.frame(
  time   = s_14$time,
  S      = s_14$surv,
  nevent = s_14$n.event,
  nrisk  = s_14$n.risk
) %>%
  mutate(
    S_prev = dplyr::lag(S, default = 1),
    h_inc  = 1 - (S / S_prev)
  )

# ================================
# 3) Plot h(t) with and without censoring (two lines)
# ================================
ggplot() +
  # courbe sans censure
  geom_step(data = km_all, aes(x = time, y = h_inc, color = "Sans censure"), size = 1.1, alpha = 0.9) +
  # courbe avec censure √† 14 h
  geom_step(data = km_14, aes(x = time, y = h_inc, color = "Censur√©e √† 14 h"), size = 1.1, alpha = 0.9, linetype = "dashed") +
  # rep√®re vertical √† 14 h
  geom_vline(xintercept = 14, linetype = "dotted") +
  labs(
    title = "Estimation du taux de risque instantan√© discret h(t)",
    subtitle = "Pleine : sans censure | Pointill√©e : censure administrative √† 14 h",
    x = "Temps (heures)",
    y = "h(t) ‚âà ŒîH(t_i) = d_i / n_i",
    color = "Type d'analyse"
  ) +
  scale_color_manual(values = c("Sans censure" = "steelblue", "Censur√©e √† 14 h" = "firebrick")) +
  theme_minimal(base_size = 13)


# (Optionnel) V√©rifier S(14) / F(14) pour info
S14_cens <- (summary(fit_14, times = 14)$surv)
F14_cens <- 1 - S14_cens
cat("Avec censure 14h: S(14) =", round(S14_cens, 4), " | F(14) =", round(F14_cens, 4), "\n")


```




2methode 

```{r}
library(muhaz)

h_est <- muhaz(df$time_hours, rep(1, nrow(df)))  # event = 1 pour tous (sans censure)
plot(h_est, main="Hazard instantan√© liss√© h(t)", xlab="Temps (heures)", ylab="h(t)")

```


## **Estimateur de BRESLOW**


## **LOG RANK**


## **COX (semi-param√©trique) -> j'ai pas compris encore**




## **C) Estimation param√©trique (ou non param√©trique, jsp dans notre cas pour l'instanbt)**

# **V - MACHINE-LEARNING**


